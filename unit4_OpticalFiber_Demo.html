<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…‰çº–å‚³è¼¸åŸç† - å…¨åå°„äº’å‹•æ•™å­¸</title>
    <style>
        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        h3 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 1em;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            font-size: 1.2em;
            margin-bottom: 30px;
        }

        .main-content {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .fiber-section {
            flex: 2;
            min-width: 500px;
        }

        .controls-section {
            flex: 1;
            min-width: 350px;
        }

        .fiber-container {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #e9ecef;
        }

        canvas {
            width: 100%;
            height: 500px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #000;
        }

        .controls {
            background: #e8f4f8;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 5px solid #3498db;
        }

        .control-group {
            margin: 20px 0;
        }

        .control-row {
            display: flex;
            align-items: center;
            margin: 15px 0;
        }

        label {
            font-weight: bold;
            color: #2c3e50;
            display: block;
            margin-bottom: 8px;
        }

        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }

        input[type="number"] {
            padding: 8px;
            border: 2px solid #3498db;
            border-radius: 5px;
            width: 100px;
            font-size: 16px;
        }

        .value-display {
            background: #3498db;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            display: inline-block;
            margin-top: 5px;
        }

        .result-box {
            background: #d4edda;
            border: 2px solid #c3e6cb;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border-left: 5px solid #28a745;
        }

        .result-box.warning {
            background: #fff3cd;
            border-color: #ffeaa7;
            border-left-color: #f39c12;
        }

        .result-box.error {
            background: #f8d7da;
            border-color: #f5c6cb;
            border-left-color: #dc3545;
        }

        .info-box {
            background: #e1ecf4;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border-left: 5px solid #17a2b8;
        }

        .formula-box {
            background: #fff3cd;
            border: 2px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            border-left: 5px solid #f39c12;
        }

        .formula {
            font-size: 1.3em;
            font-weight: bold;
            color: #2c3e50;
            margin: 10px 0;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.2em;
            font-weight: bold;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .status-indicator.success {
            background: #d4edda;
            color: #155724;
        }

        .status-indicator.fail {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status-indicator.warning {
            background: #fff3cd;
            color: #856404;
        }

        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 30px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #333;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .fiber-section, .controls-section {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”¬ å…‰çº–å‚³è¼¸åŸç†</h1>
        <h3> ä½œè€…ï¼šäºæ±ç§‘æŠ€å¤§å­¸é€šè¨Šå·¥ç¨‹ç³» é™³ä¿Šå®</h3>
        <div class="subtitle">å…¨åå°„ (Total Internal Reflection) äº’å‹•æ•™å­¸</div>

        <div class="info-box">
            <h3>ğŸ’¡ å…‰çº–å·¥ä½œåŸç†</h3>
            <p><strong>å…‰çº–</strong>åˆ©ç”¨å…¨åå°„åŸç†ä¾†å‚³è¼¸å…‰è¨Šè™Ÿã€‚å…‰çº–ç”±é«˜æŠ˜å°„ç‡çš„**æ ¸å¿ƒ(Core)**å’Œä½æŠ˜å°„ç‡çš„**åŒ…å±¤(Cladding)**çµ„æˆã€‚</p>
            <p>ç•¶å…‰ç·šå¾ç©ºæ°£é€²å…¥å…‰çº–ï¼Œ**å…¥å°„è§’ Î¸â‚** æ˜¯æŒ‡å…‰ç·šèˆ‡**å…¥å°„ç•Œé¢æ³•ç·š**ä¹‹é–“çš„å¤¾è§’ã€‚åœ¨æ ¸å¿ƒèˆ‡åŒ…å±¤ç•Œé¢ï¼Œç•¶å…¥å°„è§’ Î¸â‚ƒ å¤§æ–¼**è‡¨ç•Œè§’ Î¸c** æ™‚ï¼Œå…‰ç·šæœƒç™¼ç”Ÿå…¨åå°„ï¼ŒæŒçºŒåœ¨å…‰çº–å…§éƒ¨å‚³æ’­ã€‚</p>
        </div>

        <div class="main-content">
            <div class="fiber-section">
                <div class="fiber-container">
                    <h3>ğŸ“Š å…‰çº–çµæ§‹èˆ‡å…‰ç·šå‚³æ’­</h3>
                    <canvas id="fiberCanvas" width="800" height="500"></canvas>

                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(255, 100, 100, 0.3); border-color: #ff6464;"></div>
                            <span>æ ¸å¿ƒ (Core)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(100, 200, 100, 0.3); border-color: #64c864;"></div>
                            <span>åŒ…å±¤ (Cladding)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ffd700;"></div>
                            <span>å…‰ç·šè·¯å¾‘</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="controls-section">
                <div class="controls">
                    <h3>ğŸ›ï¸ åƒæ•¸è¨­å®š</h3>

                    <div class="control-group">
                        <label>å…¥å°„è§’åº¦ (èˆ‡æ³•ç·šçš„å¤¾è§’ Î¸â‚):</label>
                        <input type="range" id="incidentAngleSlider" min="0" max="89" value="30" step="1">
                        <div class="value-display" id="incidentAngleValue">30Â°</div>
                    </div>

                    <div class="control-group">
                        <label>æ ¸å¿ƒæŠ˜å°„ç‡ (n_core):</label>
                        <input type="number" id="nCoreInput" min="1.40" max="1.70" step="0.01" value="1.50">
                        <div class="value-display" id="nCoreValue">1.50</div>
                    </div>

                    <div class="control-group">
                        <label>åŒ…å±¤æŠ˜å°„ç‡ (n_cladding):</label>
                        <input type="number" id="nCladdingInput" min="1.40" max="1.65" step="0.01" value="1.45">
                        <div class="value-display" id="nCladdingValue">1.45</div>
                    </div>
                </div>

                <div id="statusBox" class="status-indicator success">
                    <span id="statusIcon">âœ…</span>
                    <span id="statusText">å…‰ç·šæˆåŠŸåœ¨å…‰çº–ä¸­å…¨åå°„å‚³æ’­</span>
                </div>

                <div class="result-box">
                    <h3>ğŸ“ è¨ˆç®—çµæœ</h3>
                    <p><strong>ç©ºæ°£-æ ¸å¿ƒç•Œé¢æŠ˜å°„è§’ (Î¸â‚‚):</strong> <span id="refractAngle1">--</span></p>
                    <p><strong>æ ¸å¿ƒ-åŒ…å±¤ç•Œé¢å…¥å°„è§’ (Î¸â‚ƒ):</strong> <span id="incidentAngle2">--</span></p>
                    <p><strong>è‡¨ç•Œè§’ (Î¸c):</strong> <span id="criticalAngle">--</span></p>
                    <p><strong>æ•¸å€¼å­”å¾‘ (NA):</strong> <span id="numericalAperture">--</span></p>
                    <p><strong>æ¥å—è§’ (Î¸max):</strong> <span id="acceptanceAngle">--</span></p>
                </div>

                <div class="formula-box">
                    <div class="formula">è‡¨ç•Œè§’: sin Î¸c = n_cladding / n_core</div>
                    <p style="font-size: 0.9em;">n_core = æ ¸å¿ƒæŠ˜å°„ç‡, n_cladding = åŒ…å±¤æŠ˜å°„ç‡</p>
                </div>

                <div class="formula-box">
                    <div class="formula">NA = âˆš(n_coreÂ² - n_claddingÂ²)</div>
                    <p style="font-size: 0.9em;">æ•¸å€¼å­”å¾‘æ±ºå®šå…‰çº–çš„é›†å…‰èƒ½åŠ›</p>
                </div>

                <div class="info-box">
                    <h4>ğŸ¯ å¯¦é©—å»ºè­°</h4>
                    <p><strong>è©¦è©¦çœ‹ï¼š</strong></p>
                    <ul>
                        <li>èª¿æ•´å…¥å°„è§’ï¼Œæ‰¾å‡ºæ¥å—è§’çš„ç¯„åœ</li>
                        <li>æ”¹è®Šæ ¸å¿ƒå’ŒåŒ…å±¤çš„æŠ˜å°„ç‡å·®ç•°</li>
                        <li>è§€å¯ŸæŠ˜å°„ç‡å·®ç•°å°å…¨åå°„çš„å½±éŸ¿</li>
                    </ul>
                    <p><strong>æ³¨æ„ï¼š</strong>n_core å¿…é ˆå¤§æ–¼ n_cladding</p>
                </div>
            </div>
        </div>

        <div class="info-box" style="margin-top: 30px;">
            <h3>ğŸ“š å…‰çº–å‚³è¼¸çš„é—œéµæ¢ä»¶</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 15px;">
                <div>
                    <h4>1ï¸âƒ£ æŠ˜å°„ç‡æ¢ä»¶</h4>
                    <p>æ ¸å¿ƒæŠ˜å°„ç‡å¿…é ˆå¤§æ–¼åŒ…å±¤æŠ˜å°„ç‡ (n_core > n_cladding)</p>
                </div>
                <div>
                    <h4>2ï¸âƒ£ å…¥å°„è§’æ¢ä»¶</h4>
                    <p>å¤–éƒ¨å…¥å°„è§’ Î¸â‚ å¿…é ˆå°æ–¼**æ¥å—è§’ Î¸max**</p>
                </div>
                <div>
                    <h4>3ï¸âƒ£ å…¨åå°„æ¢ä»¶</h4>
                    <p>å…‰ç·šåœ¨æ ¸å¿ƒ-åŒ…å±¤ç•Œé¢çš„å…¥å°„è§’ Î¸â‚ƒ å¿…é ˆå¤§æ–¼**è‡¨ç•Œè§’ Î¸c**</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('fiberCanvas');
        const ctx = canvas.getContext('2d');

        // æ§åˆ¶å…ƒç´ 
        const incidentAngleSlider = document.getElementById('incidentAngleSlider');
        const incidentAngleValue = document.getElementById('incidentAngleValue');
        const nCoreInput = document.getElementById('nCoreInput');
        const nCladdingInput = document.getElementById('nCladdingInput');
        const nCoreValue = document.getElementById('nCoreValue');
        const nCladdingValue = document.getElementById('nCladdingValue');

        // çµæœé¡¯ç¤ºå…ƒç´ 
        const refractAngle1 = document.getElementById('refractAngle1');
        const incidentAngle2 = document.getElementById('incidentAngle2');
        const criticalAngle = document.getElementById('criticalAngle');
        const numericalAperture = document.getElementById('numericalAperture');
        const acceptanceAngle = document.getElementById('acceptanceAngle');
        const statusBox = document.getElementById('statusBox');
        const statusIcon = document.getElementById('statusIcon');
        const statusText = document.getElementById('statusText');

        // åƒæ•¸
        let incidentAngle = 30;
        let nCore = 1.50;
        let nCladding = 1.45;
        const nAir = 1.00;

        function drawFiber() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const coreHeight = 100;
            const claddingHeight = 200;
            const centerY = canvas.height / 2;
            const fiberStartX = 150;
            const fiberLength = 600;

            // ç¹ªè£½åŒ…å±¤ (Cladding) - å¤–å±¤
            ctx.fillStyle = 'rgba(100, 200, 100, 0.3)';
            ctx.fillRect(fiberStartX, centerY - claddingHeight/2, fiberLength, claddingHeight);
            ctx.strokeStyle = '#64c864';
            ctx.lineWidth = 2;
            ctx.strokeRect(fiberStartX, centerY - claddingHeight/2, fiberLength, claddingHeight);

            // ç¹ªè£½æ ¸å¿ƒ (Core) - å…§å±¤
            ctx.fillStyle = 'rgba(255, 100, 100, 0.3)';
            ctx.fillRect(fiberStartX, centerY - coreHeight/2, fiberLength, coreHeight);
            ctx.strokeStyle = '#ff6464';
            ctx.lineWidth = 2;
            ctx.strokeRect(fiberStartX, centerY - coreHeight/2, fiberLength, coreHeight);

            // ç¹ªè£½å…‰çº–ç«¯é¢ï¼ˆå…¥å°„é¢ï¼‰- æ›´æ˜é¡¯çš„å‚ç›´ç·š
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(fiberStartX, centerY - claddingHeight/2);
            ctx.lineTo(fiberStartX, centerY + claddingHeight/2);
            ctx.stroke();

            // ç¹ªè£½å…¥å°„é»çš„**æ°´å¹³æ³•ç·š**ï¼ˆå‚ç›´æ–¼ç«¯é¢ï¼‰
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(fiberStartX - 100, centerY); // æ°´å¹³ç·š
            ctx.lineTo(fiberStartX + 100, centerY); // æ°´å¹³ç·š
            ctx.stroke();
            ctx.setLineDash([]);

            // æ¨™ç¤ºæ³•ç·š
            ctx.fillStyle = '#666';
            ctx.font = '14px Microsoft JhengHei';
            ctx.textAlign = 'center';
            ctx.fillText('æ³•ç·š', fiberStartX + 100, centerY - 15);

            // æ¨™ç±¤
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Microsoft JhengHei';
            ctx.textAlign = 'center';
            ctx.fillText('ç©ºæ°£', 75, centerY);
            ctx.fillText(`åŒ…å±¤ (n=${nCladding.toFixed(2)})`, fiberStartX + fiberLength/2, centerY - claddingHeight/2 - 15);
            ctx.fillText(`æ ¸å¿ƒ (n=${nCore.toFixed(2)})`, fiberStartX + fiberLength/2, centerY);

            // è¨ˆç®—å…‰ç·šè·¯å¾‘
            const theta1 = (incidentAngle * Math.PI) / 180; // å…¥å°„è§’ (Air to Core) - å¼§åº¦ (èˆ‡æ°´å¹³æ³•ç·šçš„å¤¾è§’)
            const nCore_over_nAir = nAir / nCore;

            // ç¬¬ä¸€æ¬¡æŠ˜å°„ï¼šç©ºæ°£åˆ°æ ¸å¿ƒ (Snell's Law: n_air * sin(theta1) = n_core * sin(theta2))
            const sinTheta2 = nCore_over_nAir * Math.sin(theta1);

            if (sinTheta2 > 1) {
                drawErrorMessage();
                updateResults(null, null, null, false, true);
                return;
            }

            const theta2 = Math.asin(sinTheta2); // é€²å…¥æ ¸å¿ƒå¾Œçš„æŠ˜å°„è§’ (èˆ‡æ°´å¹³æ³•ç·šçš„å¤¾è§’, å¼§åº¦)
            const theta2Deg = (theta2 * 180) / Math.PI; // é€²å…¥æ ¸å¿ƒå¾Œçš„æŠ˜å°„è§’ (è§’åº¦)

            // æ ¸å¿ƒ-åŒ…å±¤ç•Œé¢å…¥å°„è§’ (å…‰ç·šèˆ‡æ ¸å¿ƒ-åŒ…å±¤ç•Œé¢**å‚ç›´æ³•ç·š**çš„å¤¾è§’, å¼§åº¦)
            const theta3 = Math.PI/2 - theta2;
            const theta3Deg = (theta3 * 180) / Math.PI;

            // è¨ˆç®—è‡¨ç•Œè§’ (Snell's Law)
            const nCladding_over_nCore = nCladding / nCore;
            if (nCladding_over_nCore >= 1) {
                 drawErrorMessage();
                 updateResults(null, null, null, false, true);
                 ctx.fillStyle = '#ff6464';
                 ctx.font = 'bold 20px Microsoft JhengHei';
                 ctx.textAlign = 'center';
                 ctx.fillText('âš ï¸ n_core å¿…é ˆå¤§æ–¼ n_cladding', canvas.width/2, canvas.height/2 + 30);
                 return;
            }
            const thetaCritical = Math.asin(nCladding_over_nCore); // è‡¨ç•Œè§’ (å¼§åº¦)

            // åˆ¤æ–·æ˜¯å¦å…¨åå°„
            const isTotalReflection = theta3 >= thetaCritical;

            // ç¹ªè£½å…‰ç·š
            drawLightRay(fiberStartX, centerY, theta1, theta2, theta3, isTotalReflection, coreHeight, nCore, nCladding);

            // æ¨™è¨»è§’åº¦æ–‡å­—
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 14px Microsoft JhengHei';
            ctx.textAlign = 'left';
            // ä¿®æ­£ Î¸â‚ æ¨™è¨»ä½ç½®ï¼šé è¿‘æ³•ç·šå’Œå…¥å°„é»
            ctx.fillText(`å…¥å°„è§’ Î¸â‚ = ${incidentAngle}Â°`, fiberStartX - 60, centerY + 30); 

            ctx.fillStyle = '#00ff00';
            // ä¿®æ­£ Î¸â‚‚ æ¨™è¨»ä½ç½®ï¼šé è¿‘æ³•ç·šå’ŒæŠ˜å°„é»
            ctx.fillText(`æŠ˜å°„è§’ Î¸â‚‚ = ${theta2Deg.toFixed(1)}Â°`, fiberStartX + 10, centerY - 25);

            // æ›´æ–°çµæœ (å‚³éè§’åº¦åˆ¶çš„å€¼ä»¥æ–¹ä¾¿é¡¯ç¤º)
            updateResults(theta2Deg, theta3Deg, thetaCritical, isTotalReflection, false);
        }
        
        function drawArrowhead(ctx, fromX, fromY, toX, toY) {
            const headlen = 10;
            const angle = Math.atan2(toY - fromY, toX - fromX);

            ctx.fillStyle = ctx.strokeStyle; 
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6),
                       toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6),
                       toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function drawLightRay(startX, centerY, theta1, theta2, theta3, isTotalReflection, coreHeight, nCore, nCladding) {
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffd700';

            // å…¥å°„å…‰ç·šï¼ˆç©ºæ°£ä¸­ï¼‰ï¼Œä¾†è‡ªå·¦ä¸‹æ–¹
            const incidentLength = 120;
            const x0 = startX - incidentLength * Math.cos(theta1);
            const y0 = centerY + incidentLength * Math.sin(theta1); 

            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(startX, centerY);
            ctx.stroke();

            drawArrowhead(ctx, x0, y0, startX, centerY);

            const propagationAngle = theta2; 

            let goingDown = false; // åˆå§‹å¾€å³ä¸Šæ–¹å‚³æ’­ (y åº§æ¨™æ¸›å°‘)

            if (isTotalReflection) {
                // å…¨åå°„ï¼šç¹ªè£½Zå­—å½¢è·¯å¾‘
                let currentX = startX;
                let currentY = centerY;

                const maxY = centerY + coreHeight/2;
                const minY = centerY - coreHeight/2;
                
                // ç¹ªè£½ç¬¬ä¸€æ®µæŠ˜å°„å…‰ç·š (æ ¸å¿ƒå…§)
                let targetY1 = minY; // ç¸½æ˜¯å…ˆå¾€ä¸Šå°„ (minY)
                let deltaY1 = Math.abs(targetY1 - currentY);
                
                let deltaX1 = deltaY1 / Math.tan(propagationAngle);
                let nextX1 = currentX + deltaX1;
                let nextY1 = targetY1;

                const maxDrawX = startX + 580;
                let continueDrawing = true;

                if (nextX1 > maxDrawX) {
                    deltaX1 = maxDrawX - currentX;
                    nextY1 = currentY - deltaX1 * Math.tan(propagationAngle);
                    nextX1 = maxDrawX;
                    continueDrawing = false;
                }

                ctx.beginPath();
                ctx.moveTo(currentX, currentY);
                ctx.lineTo(nextX1, nextY1);
                ctx.stroke();

                drawArrowhead(ctx, currentX, currentY, nextX1, nextY1);

                if (!continueDrawing) {
                    ctx.shadowBlur = 0;
                    return;
                }

                currentX = nextX1;
                currentY = nextY1;
                goingDown = true; // ä¸‹ä¸€æ¬¡åå°„å¾Œå¾€ä¸‹å°„

                for (let i = 0; i < 4; i++) {
                    let targetY = goingDown ? maxY : minY;
                    let deltaY = Math.abs(targetY - currentY);
                    let deltaX = deltaY / Math.tan(propagationAngle);
                    let nextX = currentX + deltaX;
                    let nextY = targetY;

                    if (nextX > maxDrawX) {
                        deltaX = maxDrawX - currentX;
                        nextY = goingDown ?
                            currentY + deltaX * Math.tan(propagationAngle) :
                            currentY - deltaX * Math.tan(propagationAngle);
                        nextX = maxDrawX;
                    }

                    ctx.beginPath();
                    ctx.moveTo(currentX, currentY);
                    ctx.lineTo(nextX, nextY);
                    ctx.stroke();

                    drawArrowhead(ctx, currentX, currentY, nextX, nextY);

                    if (nextX >= maxDrawX) break;

                    currentX = nextX;
                    currentY = nextY;
                    goingDown = !goingDown;
                }
            } else {
                // å…‰ç·šå°„å‡ºæ ¸å¿ƒï¼ˆä¸æ˜¯å…¨åå°„ï¼‰
                const minY = centerY - coreHeight/2;

                let exitY = minY; // å°„å‡ºé»æ˜¯é ‚éƒ¨ç•Œé¢
                let deltaY = Math.abs(exitY - centerY);
                let exitX = startX + deltaY / Math.tan(propagationAngle);

                // ç¹ªè£½åˆ°é‚Šç•Œçš„å…‰ç·š (æ ¸å¿ƒå…§)
                ctx.beginPath();
                ctx.moveTo(startX, centerY);
                ctx.lineTo(exitX, exitY);
                ctx.stroke();
                drawArrowhead(ctx, startX, centerY, exitX, exitY);

                // è¨ˆç®—æŠ˜å°„åˆ°åŒ…å±¤ (Cladding) å¾Œçš„è§’åº¦ (Snell's Law)
                const sinTheta4 = (nCore * Math.sin(theta3)) / nCladding;
                const theta4 = Math.asin(sinTheta4);
                const claddingPropagationAngle = Math.PI / 2 - theta4; 

                // ç¹ªè£½ç©¿é€åŒ…å±¤çš„å…‰ç·š
                ctx.strokeStyle = '#64c864';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#64c864';

                const refractLength = 60;
                
                // å°„å‡ºé»æ˜¯ minYï¼Œå…‰ç·šå‘å³ä¸Šæ–¹æŠ˜å°„ (y åº§æ¨™ç¹¼çºŒæ¸›å°‘)
                const finalX = exitX + refractLength * Math.cos(claddingPropagationAngle);
                const finalY = exitY - refractLength * Math.sin(claddingPropagationAngle);

                ctx.beginPath();
                ctx.moveTo(exitX, exitY);
                ctx.lineTo(finalX, finalY);
                ctx.stroke();
                drawArrowhead(ctx, exitX, exitY, finalX, finalY);

                // æ¨™ç¤ºå…‰ç·šæå¤±
                ctx.fillStyle = '#ff6464';
                ctx.font = '14px Microsoft JhengHei';
                ctx.textAlign = 'left';
                ctx.fillText('å…‰ç·šæå¤±', finalX + 5, finalY);
            }

            ctx.shadowBlur = 0;
        }

        function drawErrorMessage() {
            ctx.fillStyle = '#ff6464';
            ctx.font = 'bold 20px Microsoft JhengHei';
            ctx.textAlign = 'center';
            ctx.fillText('âš ï¸ å…¥å°„è§’å¤ªå¤§ï¼Œå…‰ç·šç„¡æ³•é€²å…¥å…‰çº–æ ¸å¿ƒ', canvas.width/2, canvas.height/2);
        }

        function updateResults(theta2Deg, theta3Deg, thetaCriticalRad, isTotalReflection, cannotEnter) {
            // æ•¸å€¼å­”å¾‘
            const NA = Math.sqrt(nCore * nCore - nCladding * nCladding);
            numericalAperture.textContent = NA.toFixed(3);

            // æ¥å—è§’ (NA = n_air * sin(theta_max), å‡è¨­ n_air = 1.0)
            const thetaMax = Math.asin(NA / nAir);
            const thetaMaxDeg = (thetaMax * 180) / Math.PI;
            acceptanceAngle.textContent = thetaMaxDeg.toFixed(1) + 'Â°';

            if (cannotEnter) {
                refractAngle1.textContent = 'ç„¡æ³•é€²å…¥';
                incidentAngle2.textContent = 'ç„¡æ³•é€²å…¥';
                criticalAngle.textContent = 'ç„¡æ³•è¨ˆç®—';
                statusBox.className = 'status-indicator fail';
                statusIcon.textContent = 'âŒ';
                statusText.textContent = 'å…¥å°„è§’éå¤§ï¼Œå…‰ç·šç„¡æ³•é€²å…¥å…‰çº–ï¼Œæˆ– n_core <= n_cladding';
                return;
            }

            // æŠ˜å°„è§’ (Air to Core)
            refractAngle1.textContent = theta2Deg.toFixed(1) + 'Â°';

            // æ ¸å¿ƒ-åŒ…å±¤ç•Œé¢å…¥å°„è§’
            incidentAngle2.textContent = theta3Deg.toFixed(1) + 'Â°';

            // è‡¨ç•Œè§’ (å¼§åº¦è½‰è§’åº¦)
            const thetaCriticalDeg = (thetaCriticalRad * 180) / Math.PI;
            criticalAngle.textContent = thetaCriticalDeg.toFixed(1) + 'Â°';

            // ç‹€æ…‹ (ä¿®æ­£: è€ƒæ…®æ¥å—è§’é™åˆ¶)
            if (isTotalReflection) {
                if (incidentAngle <= thetaMaxDeg) {
                    statusBox.className = 'status-indicator success';
                    statusIcon.textContent = 'âœ…';
                    statusText.textContent = `å…‰ç·šæˆåŠŸåœ¨å…‰çº–ä¸­å…¨åå°„å‚³æ’­ (Î¸â‚=${incidentAngle}Â° åœ¨æ¥å—è§’ Î¸max=${thetaMaxDeg.toFixed(1)}Â° å…§)`;
                } else {
                    statusBox.className = 'status-indicator warning';
                    statusIcon.textContent = 'âš ï¸';
                    statusText.textContent = `å…‰ç·šåœ¨æ ¸å¿ƒ-åŒ…å±¤ç•Œé¢ç™¼ç”Ÿå…¨åå°„ï¼Œä½†å…¥å°„è§’ Î¸â‚=${incidentAngle}Â° å·²è¶…å‡ºå…‰çº–æ¥å—è§’ Î¸max=${thetaMaxDeg.toFixed(1)}Â°`;
                }
            } else {
                statusBox.className = 'status-indicator fail';
                statusIcon.textContent = 'âŒ';
                statusText.textContent = `å…‰ç·šæœƒç©¿é€åŒ…å±¤ï¼Œç„¡æ³•åœ¨å…‰çº–ä¸­å‚³æ’­ (Î¸â‚ƒ=${theta3Deg.toFixed(1)}Â° < è‡¨ç•Œè§’ Î¸c=${thetaCriticalDeg.toFixed(1)}Â°)`;
            }
        }

        function updateValues() {
            incidentAngle = parseFloat(incidentAngleSlider.value);
            nCore = parseFloat(nCoreInput.value);
            nCladding = parseFloat(nCladdingInput.value);

            // é©—è­‰æŠ˜å°„ç‡
            if (nCore <= nCladding) {
                nCore = nCladding + 0.01;
                nCoreInput.value = nCore.toFixed(2);
            }

            incidentAngleValue.textContent = incidentAngle + 'Â°';
            nCoreValue.textContent = nCore.toFixed(2);
            nCladdingValue.textContent = nCladding.toFixed(2);

            drawFiber();
        }

        // äº‹ä»¶ç›£è½
        incidentAngleSlider.addEventListener('input', updateValues);
        nCoreInput.addEventListener('input', updateValues);
        nCladdingInput.addEventListener('input', updateValues);

        // åˆå§‹åŒ–
        updateValues();
    </script>
</body>
</html>