<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>光纖傳輸原理 - 全反射互動教學</title>
    <style>
        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        h3 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 1em;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            font-size: 1.2em;
            margin-bottom: 30px;
        }

        .main-content {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .fiber-section {
            flex: 2;
            min-width: 500px;
        }

        .controls-section {
            flex: 1;
            min-width: 350px;
        }

        .fiber-container {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #e9ecef;
        }

        canvas {
            width: 100%;
            height: 500px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #000;
        }

        .controls {
            background: #e8f4f8;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 5px solid #3498db;
        }

        .control-group {
            margin: 20px 0;
        }

        .control-row {
            display: flex;
            align-items: center;
            margin: 15px 0;
        }

        label {
            font-weight: bold;
            color: #2c3e50;
            display: block;
            margin-bottom: 8px;
        }

        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }

        input[type="number"] {
            padding: 8px;
            border: 2px solid #3498db;
            border-radius: 5px;
            width: 100px;
            font-size: 16px;
        }

        .value-display {
            background: #3498db;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            display: inline-block;
            margin-top: 5px;
        }

        .result-box {
            background: #d4edda;
            border: 2px solid #c3e6cb;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border-left: 5px solid #28a745;
        }

        .result-box.warning {
            background: #fff3cd;
            border-color: #ffeaa7;
            border-left-color: #f39c12;
        }

        .result-box.error {
            background: #f8d7da;
            border-color: #f5c6cb;
            border-left-color: #dc3545;
        }

        .info-box {
            background: #e1ecf4;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border-left: 5px solid #17a2b8;
        }

        .formula-box {
            background: #fff3cd;
            border: 2px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            border-left: 5px solid #f39c12;
        }

        .formula {
            font-size: 1.3em;
            font-weight: bold;
            color: #2c3e50;
            margin: 10px 0;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.2em;
            font-weight: bold;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .status-indicator.success {
            background: #d4edda;
            color: #155724;
        }

        .status-indicator.fail {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status-indicator.warning {
            background: #fff3cd;
            color: #856404;
        }

        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 30px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #333;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .fiber-section, .controls-section {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔬 光纖傳輸原理</h1>
        <h3> 作者：亞東科技大學通訊工程系 陳俊宏</h3>
        <div class="subtitle">全反射 (Total Internal Reflection) 互動教學</div>

        <div class="info-box">
            <h3>💡 光纖工作原理</h3>
            <p><strong>光纖</strong>利用全反射原理來傳輸光訊號。光纖由高折射率的**核心(Core)**和低折射率的**包層(Cladding)**組成。</p>
            <p>當光線從空氣進入光纖，**入射角 θ₁** 是指光線與**入射界面法線**之間的夾角。在核心與包層界面，當入射角 θ₃ 大於**臨界角 θc** 時，光線會發生全反射，持續在光纖內部傳播。</p>
        </div>

        <div class="main-content">
            <div class="fiber-section">
                <div class="fiber-container">
                    <h3>📊 光纖結構與光線傳播</h3>
                    <canvas id="fiberCanvas" width="800" height="500"></canvas>

                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(255, 100, 100, 0.3); border-color: #ff6464;"></div>
                            <span>核心 (Core)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(100, 200, 100, 0.3); border-color: #64c864;"></div>
                            <span>包層 (Cladding)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ffd700;"></div>
                            <span>光線路徑</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="controls-section">
                <div class="controls">
                    <h3>🎛️ 參數設定</h3>

                    <div class="control-group">
                        <label>入射角度 (與法線的夾角 θ₁):</label>
                        <input type="range" id="incidentAngleSlider" min="0" max="89" value="30" step="1">
                        <div class="value-display" id="incidentAngleValue">30°</div>
                    </div>

                    <div class="control-group">
                        <label>核心折射率 (n_core):</label>
                        <input type="number" id="nCoreInput" min="1.40" max="1.70" step="0.01" value="1.50">
                        <div class="value-display" id="nCoreValue">1.50</div>
                    </div>

                    <div class="control-group">
                        <label>包層折射率 (n_cladding):</label>
                        <input type="number" id="nCladdingInput" min="1.40" max="1.65" step="0.01" value="1.45">
                        <div class="value-display" id="nCladdingValue">1.45</div>
                    </div>
                </div>

                <div id="statusBox" class="status-indicator success">
                    <span id="statusIcon">✅</span>
                    <span id="statusText">光線成功在光纖中全反射傳播</span>
                </div>

                <div class="result-box">
                    <h3>📐 計算結果</h3>
                    <p><strong>空氣-核心界面折射角 (θ₂):</strong> <span id="refractAngle1">--</span></p>
                    <p><strong>核心-包層界面入射角 (θ₃):</strong> <span id="incidentAngle2">--</span></p>
                    <p><strong>臨界角 (θc):</strong> <span id="criticalAngle">--</span></p>
                    <p><strong>數值孔徑 (NA):</strong> <span id="numericalAperture">--</span></p>
                    <p><strong>接受角 (θmax):</strong> <span id="acceptanceAngle">--</span></p>
                </div>

                <div class="formula-box">
                    <div class="formula">臨界角: sin θc = n_cladding / n_core</div>
                    <p style="font-size: 0.9em;">n_core = 核心折射率, n_cladding = 包層折射率</p>
                </div>

                <div class="formula-box">
                    <div class="formula">NA = √(n_core² - n_cladding²)</div>
                    <p style="font-size: 0.9em;">數值孔徑決定光纖的集光能力</p>
                </div>

                <div class="info-box">
                    <h4>🎯 實驗建議</h4>
                    <p><strong>試試看：</strong></p>
                    <ul>
                        <li>調整入射角，找出接受角的範圍</li>
                        <li>改變核心和包層的折射率差異</li>
                        <li>觀察折射率差異對全反射的影響</li>
                    </ul>
                    <p><strong>注意：</strong>n_core 必須大於 n_cladding</p>
                </div>
            </div>
        </div>

        <div class="info-box" style="margin-top: 30px;">
            <h3>📚 光纖傳輸的關鍵條件</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 15px;">
                <div>
                    <h4>1️⃣ 折射率條件</h4>
                    <p>核心折射率必須大於包層折射率 (n_core > n_cladding)</p>
                </div>
                <div>
                    <h4>2️⃣ 入射角條件</h4>
                    <p>外部入射角 θ₁ 必須小於**接受角 θmax**</p>
                </div>
                <div>
                    <h4>3️⃣ 全反射條件</h4>
                    <p>光線在核心-包層界面的入射角 θ₃ 必須大於**臨界角 θc**</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('fiberCanvas');
        const ctx = canvas.getContext('2d');

        // 控制元素
        const incidentAngleSlider = document.getElementById('incidentAngleSlider');
        const incidentAngleValue = document.getElementById('incidentAngleValue');
        const nCoreInput = document.getElementById('nCoreInput');
        const nCladdingInput = document.getElementById('nCladdingInput');
        const nCoreValue = document.getElementById('nCoreValue');
        const nCladdingValue = document.getElementById('nCladdingValue');

        // 結果顯示元素
        const refractAngle1 = document.getElementById('refractAngle1');
        const incidentAngle2 = document.getElementById('incidentAngle2');
        const criticalAngle = document.getElementById('criticalAngle');
        const numericalAperture = document.getElementById('numericalAperture');
        const acceptanceAngle = document.getElementById('acceptanceAngle');
        const statusBox = document.getElementById('statusBox');
        const statusIcon = document.getElementById('statusIcon');
        const statusText = document.getElementById('statusText');

        // 參數
        let incidentAngle = 30;
        let nCore = 1.50;
        let nCladding = 1.45;
        const nAir = 1.00;

        function drawFiber() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const coreHeight = 100;
            const claddingHeight = 200;
            const centerY = canvas.height / 2;
            const fiberStartX = 150;
            const fiberLength = 600;

            // 繪製包層 (Cladding) - 外層
            ctx.fillStyle = 'rgba(100, 200, 100, 0.3)';
            ctx.fillRect(fiberStartX, centerY - claddingHeight/2, fiberLength, claddingHeight);
            ctx.strokeStyle = '#64c864';
            ctx.lineWidth = 2;
            ctx.strokeRect(fiberStartX, centerY - claddingHeight/2, fiberLength, claddingHeight);

            // 繪製核心 (Core) - 內層
            ctx.fillStyle = 'rgba(255, 100, 100, 0.3)';
            ctx.fillRect(fiberStartX, centerY - coreHeight/2, fiberLength, coreHeight);
            ctx.strokeStyle = '#ff6464';
            ctx.lineWidth = 2;
            ctx.strokeRect(fiberStartX, centerY - coreHeight/2, fiberLength, coreHeight);

            // 繪製光纖端面（入射面）- 更明顯的垂直線
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(fiberStartX, centerY - claddingHeight/2);
            ctx.lineTo(fiberStartX, centerY + claddingHeight/2);
            ctx.stroke();

            // 繪製入射點的**水平法線**（垂直於端面）
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(fiberStartX - 100, centerY); // 水平線
            ctx.lineTo(fiberStartX + 100, centerY); // 水平線
            ctx.stroke();
            ctx.setLineDash([]);

            // 標示法線
            ctx.fillStyle = '#666';
            ctx.font = '14px Microsoft JhengHei';
            ctx.textAlign = 'center';
            ctx.fillText('法線', fiberStartX + 100, centerY - 15);

            // 標籤
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Microsoft JhengHei';
            ctx.textAlign = 'center';
            ctx.fillText('空氣', 75, centerY);
            ctx.fillText(`包層 (n=${nCladding.toFixed(2)})`, fiberStartX + fiberLength/2, centerY - claddingHeight/2 - 15);
            ctx.fillText(`核心 (n=${nCore.toFixed(2)})`, fiberStartX + fiberLength/2, centerY);

            // 計算光線路徑
            const theta1 = (incidentAngle * Math.PI) / 180; // 入射角 (Air to Core) - 弧度 (與水平法線的夾角)
            const nCore_over_nAir = nAir / nCore;

            // 第一次折射：空氣到核心 (Snell's Law: n_air * sin(theta1) = n_core * sin(theta2))
            const sinTheta2 = nCore_over_nAir * Math.sin(theta1);

            if (sinTheta2 > 1) {
                drawErrorMessage();
                updateResults(null, null, null, false, true);
                return;
            }

            const theta2 = Math.asin(sinTheta2); // 進入核心後的折射角 (與水平法線的夾角, 弧度)
            const theta2Deg = (theta2 * 180) / Math.PI; // 進入核心後的折射角 (角度)

            // 核心-包層界面入射角 (光線與核心-包層界面**垂直法線**的夾角, 弧度)
            const theta3 = Math.PI/2 - theta2;
            const theta3Deg = (theta3 * 180) / Math.PI;

            // 計算臨界角 (Snell's Law)
            const nCladding_over_nCore = nCladding / nCore;
            if (nCladding_over_nCore >= 1) {
                 drawErrorMessage();
                 updateResults(null, null, null, false, true);
                 ctx.fillStyle = '#ff6464';
                 ctx.font = 'bold 20px Microsoft JhengHei';
                 ctx.textAlign = 'center';
                 ctx.fillText('⚠️ n_core 必須大於 n_cladding', canvas.width/2, canvas.height/2 + 30);
                 return;
            }
            const thetaCritical = Math.asin(nCladding_over_nCore); // 臨界角 (弧度)

            // 判斷是否全反射
            const isTotalReflection = theta3 >= thetaCritical;

            // 繪製光線
            drawLightRay(fiberStartX, centerY, theta1, theta2, theta3, isTotalReflection, coreHeight, nCore, nCladding);

            // 標註角度文字
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 14px Microsoft JhengHei';
            ctx.textAlign = 'left';
            // 修正 θ₁ 標註位置：靠近法線和入射點
            ctx.fillText(`入射角 θ₁ = ${incidentAngle}°`, fiberStartX - 60, centerY + 30); 

            ctx.fillStyle = '#00ff00';
            // 修正 θ₂ 標註位置：靠近法線和折射點
            ctx.fillText(`折射角 θ₂ = ${theta2Deg.toFixed(1)}°`, fiberStartX + 10, centerY - 25);

            // 更新結果 (傳遞角度制的值以方便顯示)
            updateResults(theta2Deg, theta3Deg, thetaCritical, isTotalReflection, false);
        }
        
        function drawArrowhead(ctx, fromX, fromY, toX, toY) {
            const headlen = 10;
            const angle = Math.atan2(toY - fromY, toX - fromX);

            ctx.fillStyle = ctx.strokeStyle; 
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6),
                       toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6),
                       toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function drawLightRay(startX, centerY, theta1, theta2, theta3, isTotalReflection, coreHeight, nCore, nCladding) {
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffd700';

            // 入射光線（空氣中），來自左下方
            const incidentLength = 120;
            const x0 = startX - incidentLength * Math.cos(theta1);
            const y0 = centerY + incidentLength * Math.sin(theta1); 

            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(startX, centerY);
            ctx.stroke();

            drawArrowhead(ctx, x0, y0, startX, centerY);

            const propagationAngle = theta2; 

            let goingDown = false; // 初始往右上方傳播 (y 座標減少)

            if (isTotalReflection) {
                // 全反射：繪製Z字形路徑
                let currentX = startX;
                let currentY = centerY;

                const maxY = centerY + coreHeight/2;
                const minY = centerY - coreHeight/2;
                
                // 繪製第一段折射光線 (核心內)
                let targetY1 = minY; // 總是先往上射 (minY)
                let deltaY1 = Math.abs(targetY1 - currentY);
                
                let deltaX1 = deltaY1 / Math.tan(propagationAngle);
                let nextX1 = currentX + deltaX1;
                let nextY1 = targetY1;

                const maxDrawX = startX + 580;
                let continueDrawing = true;

                if (nextX1 > maxDrawX) {
                    deltaX1 = maxDrawX - currentX;
                    nextY1 = currentY - deltaX1 * Math.tan(propagationAngle);
                    nextX1 = maxDrawX;
                    continueDrawing = false;
                }

                ctx.beginPath();
                ctx.moveTo(currentX, currentY);
                ctx.lineTo(nextX1, nextY1);
                ctx.stroke();

                drawArrowhead(ctx, currentX, currentY, nextX1, nextY1);

                if (!continueDrawing) {
                    ctx.shadowBlur = 0;
                    return;
                }

                currentX = nextX1;
                currentY = nextY1;
                goingDown = true; // 下一次反射後往下射

                for (let i = 0; i < 4; i++) {
                    let targetY = goingDown ? maxY : minY;
                    let deltaY = Math.abs(targetY - currentY);
                    let deltaX = deltaY / Math.tan(propagationAngle);
                    let nextX = currentX + deltaX;
                    let nextY = targetY;

                    if (nextX > maxDrawX) {
                        deltaX = maxDrawX - currentX;
                        nextY = goingDown ?
                            currentY + deltaX * Math.tan(propagationAngle) :
                            currentY - deltaX * Math.tan(propagationAngle);
                        nextX = maxDrawX;
                    }

                    ctx.beginPath();
                    ctx.moveTo(currentX, currentY);
                    ctx.lineTo(nextX, nextY);
                    ctx.stroke();

                    drawArrowhead(ctx, currentX, currentY, nextX, nextY);

                    if (nextX >= maxDrawX) break;

                    currentX = nextX;
                    currentY = nextY;
                    goingDown = !goingDown;
                }
            } else {
                // 光線射出核心（不是全反射）
                const minY = centerY - coreHeight/2;

                let exitY = minY; // 射出點是頂部界面
                let deltaY = Math.abs(exitY - centerY);
                let exitX = startX + deltaY / Math.tan(propagationAngle);

                // 繪製到邊界的光線 (核心內)
                ctx.beginPath();
                ctx.moveTo(startX, centerY);
                ctx.lineTo(exitX, exitY);
                ctx.stroke();
                drawArrowhead(ctx, startX, centerY, exitX, exitY);

                // 計算折射到包層 (Cladding) 後的角度 (Snell's Law)
                const sinTheta4 = (nCore * Math.sin(theta3)) / nCladding;
                const theta4 = Math.asin(sinTheta4);
                const claddingPropagationAngle = Math.PI / 2 - theta4; 

                // 繪製穿透包層的光線
                ctx.strokeStyle = '#64c864';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#64c864';

                const refractLength = 60;
                
                // 射出點是 minY，光線向右上方折射 (y 座標繼續減少)
                const finalX = exitX + refractLength * Math.cos(claddingPropagationAngle);
                const finalY = exitY - refractLength * Math.sin(claddingPropagationAngle);

                ctx.beginPath();
                ctx.moveTo(exitX, exitY);
                ctx.lineTo(finalX, finalY);
                ctx.stroke();
                drawArrowhead(ctx, exitX, exitY, finalX, finalY);

                // 標示光線損失
                ctx.fillStyle = '#ff6464';
                ctx.font = '14px Microsoft JhengHei';
                ctx.textAlign = 'left';
                ctx.fillText('光線損失', finalX + 5, finalY);
            }

            ctx.shadowBlur = 0;
        }

        function drawErrorMessage() {
            ctx.fillStyle = '#ff6464';
            ctx.font = 'bold 20px Microsoft JhengHei';
            ctx.textAlign = 'center';
            ctx.fillText('⚠️ 入射角太大，光線無法進入光纖核心', canvas.width/2, canvas.height/2);
        }

        function updateResults(theta2Deg, theta3Deg, thetaCriticalRad, isTotalReflection, cannotEnter) {
            // 數值孔徑
            const NA = Math.sqrt(nCore * nCore - nCladding * nCladding);
            numericalAperture.textContent = NA.toFixed(3);

            // 接受角 (NA = n_air * sin(theta_max), 假設 n_air = 1.0)
            const thetaMax = Math.asin(NA / nAir);
            const thetaMaxDeg = (thetaMax * 180) / Math.PI;
            acceptanceAngle.textContent = thetaMaxDeg.toFixed(1) + '°';

            if (cannotEnter) {
                refractAngle1.textContent = '無法進入';
                incidentAngle2.textContent = '無法進入';
                criticalAngle.textContent = '無法計算';
                statusBox.className = 'status-indicator fail';
                statusIcon.textContent = '❌';
                statusText.textContent = '入射角過大，光線無法進入光纖，或 n_core <= n_cladding';
                return;
            }

            // 折射角 (Air to Core)
            refractAngle1.textContent = theta2Deg.toFixed(1) + '°';

            // 核心-包層界面入射角
            incidentAngle2.textContent = theta3Deg.toFixed(1) + '°';

            // 臨界角 (弧度轉角度)
            const thetaCriticalDeg = (thetaCriticalRad * 180) / Math.PI;
            criticalAngle.textContent = thetaCriticalDeg.toFixed(1) + '°';

            // 狀態 (修正: 考慮接受角限制)
            if (isTotalReflection) {
                if (incidentAngle <= thetaMaxDeg) {
                    statusBox.className = 'status-indicator success';
                    statusIcon.textContent = '✅';
                    statusText.textContent = `光線成功在光纖中全反射傳播 (θ₁=${incidentAngle}° 在接受角 θmax=${thetaMaxDeg.toFixed(1)}° 內)`;
                } else {
                    statusBox.className = 'status-indicator warning';
                    statusIcon.textContent = '⚠️';
                    statusText.textContent = `光線在核心-包層界面發生全反射，但入射角 θ₁=${incidentAngle}° 已超出光纖接受角 θmax=${thetaMaxDeg.toFixed(1)}°`;
                }
            } else {
                statusBox.className = 'status-indicator fail';
                statusIcon.textContent = '❌';
                statusText.textContent = `光線會穿透包層，無法在光纖中傳播 (θ₃=${theta3Deg.toFixed(1)}° < 臨界角 θc=${thetaCriticalDeg.toFixed(1)}°)`;
            }
        }

        function updateValues() {
            incidentAngle = parseFloat(incidentAngleSlider.value);
            nCore = parseFloat(nCoreInput.value);
            nCladding = parseFloat(nCladdingInput.value);

            // 驗證折射率
            if (nCore <= nCladding) {
                nCore = nCladding + 0.01;
                nCoreInput.value = nCore.toFixed(2);
            }

            incidentAngleValue.textContent = incidentAngle + '°';
            nCoreValue.textContent = nCore.toFixed(2);
            nCladdingValue.textContent = nCladding.toFixed(2);

            drawFiber();
        }

        // 事件監聽
        incidentAngleSlider.addEventListener('input', updateValues);
        nCoreInput.addEventListener('input', updateValues);
        nCladdingInput.addEventListener('input', updateValues);

        // 初始化
        updateValues();
    </script>
</body>
</html>